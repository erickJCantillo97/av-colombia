import {
  printValue
} from "./chunk-WVQXHJEP.js";
import "./chunk-LK32TJAX.js";

// node_modules/yup-locales/dist/yup-locales.esm.js
var mixed = {
  "default": "${path} غير صالح.",
  required: "${path} هو حقل مطلوب",
  defined: "${path} يجب تعريفها",
  notNull: "${path} لا يمكن أن يكون فارغًا",
  oneOf: "${path} يجب أن تكون واحدة من القيم التالية: ${values}",
  notOneOf: "${path} يجب ألا تكون واحدة من القيم التالية: ${values}",
  notType: function notType(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " يجب أن يكون `" + type + "` نوع, " + ("لكن القيمة النهائية كانت: `" + printValue(value, true) + "` `") + (isCast ? " (يلقي من القيمة `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n إذا كان المقصود "NULL" كقيمة فارغة ، فتأكد من وضع علامة على المخطط `.nullable()`';
    }
    return msg;
  }
};
var string = {
  length: "${path} يجب أن يكون بالضبط ${length} أحرف",
  min: "${path} يجب أن تكون أحرفًا على الأقل ${min}",
  max: "${path} يجب أن تكون على الأكثر ${max} أحرف",
  matches: '${path} يجب أن يتطابق مع ما يلي: "${regex}"',
  email: "${path} يجب أن يكون بريدًا إلكترونيًا صالحًا",
  url: "${path} يجب أن يكون عنوان URL صالح",
  uuid: "${path} يجب أن يكون uuid صالح",
  trim: "${path} يجب أن تكون سلسلة مقلدة",
  lowercase: "${path} يجب أن تكون سلسلة صغيرة",
  uppercase: "${path} يجب أن تكون سلسلة حالة علوية"
};
var number = {
  min: "${path} يجب أن تكون أكبر من أو تساوي ${min}",
  max: "${path} يجب أن يكون أقل من أو يساوي ${max}",
  lessThan: "${path} يجب أن يكون أقل من ${less}",
  moreThan: "${path} يجب أن تكون أكبر من ${more}",
  positive: "${path} يجب أن يكون رقمًا إيجابيًا",
  negative: "${path} يجب أن يكون رقمًا سالبًا",
  integer: "${path} يجب أن يكون عدد صحيح"
};
var date = {
  min: "يجب أن يكون الحقل ${path} متأخراً عن ${min}",
  max: "يجب أن يكون الحقل ${path} في وقت سابق من ${max}"
};
var _boolean = {
  isValue: "${path} يجب أن يكون الحقل ${value}"
};
var object = {
  noUnknown: "${path} لا يمكن أن يحتوي الحقل على مفاتيح غير محددة في شكل الكائن"
};
var array = {
  min: "${path} يجب أن يكون للحقل عناصر على الأقل ${min}",
  max: "${path} يجب أن يحتوي الحقل على أقل من أو يساوي ${max} عناصر",
  length: "${path} يجب أن يكون لديها ${length} عناصر"
};
var ar = {
  __proto__: null,
  mixed,
  string,
  number,
  date,
  boolean: _boolean,
  object,
  array
};
var mixed$1 = {
  "default": "${path} е невалидно",
  required: "${path} е задължително поле",
  defined: "${path} трябва да бъде дефинирано",
  notNull: "${path} не може да бъде празно",
  oneOf: "${path} трябва да бъде една от следните стойности: ${values}",
  notOneOf: "${path} не трябва да бъде някоя от следните стойности: ${values}",
  notType: function notType2(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " трябва да бъде `" + type + "` тип, " + ("Но крайната стойност беше: `" + printValue(value, true) + "`") + (isCast ? " (преобразувано от стойност `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Ако "null" е предвидено като празна стойност, уверете се, че схемата е маркирана като `.nullable()`';
    }
    return msg;
  }
};
var string$1 = {
  length: "${path} трябва да бъде точно ${length} символа",
  min: "${path} трябва да бъде поне ${min} символа",
  max: "${path} трябва да бъде максимум ${max} символа",
  matches: '${path} трябва да съвпада с: "${regex}"',
  email: "${path} трябва да бъде валиден имейл",
  url: "${path} трябва да бъде валиден URL",
  uuid: "${path} трябва да бъде валиден UUID",
  trim: "${path} трябва да бъде подрязан низ",
  lowercase: "${path} трябва да бъде с малки букви",
  uppercase: "${path} трябва да бъде с големи букви"
};
var number$1 = {
  min: "${path} трябва да бъде по-голямо или равно на ${min}",
  max: "${path} трябва да бъде по-малко или равно на ${max}",
  lessThan: "${path} трябва да бъде по-малко от ${less}",
  moreThan: "${path} трябва да бъде по-голямо от ${more}",
  positive: "${path} трябва да бъде положително число",
  negative: "${path} трябва да бъде отрицателно число",
  integer: "${path} трябва да бъде цяло число"
};
var date$1 = {
  min: "${path} полето трябва да бъде след ${min}",
  max: "${path} полето трябва да бъде преди ${max}"
};
var _boolean$1 = {
  isValue: "${path} полето трябва да бъде ${value}"
};
var object$1 = {
  noUnknown: "${path} полето има неспецифицирани ключове: ${unknown}"
};
var array$1 = {
  min: "${path} полето трябва да има поне ${min} елемента",
  max: "${path} полето трябва да има не повече от ${max} елемента",
  length: "${path} трябва да има ${length} елемента"
};
var bg = {
  __proto__: null,
  mixed: mixed$1,
  string: string$1,
  number: number$1,
  date: date$1,
  boolean: _boolean$1,
  object: object$1,
  array: array$1
};
var mixed$2 = {
  "default": "${path} je nevažeći.",
  required: "${path} je obavezno polje",
  defined: "${path} mora biti definisan",
  notNull: "${path} ne može biti null",
  oneOf: "${path} mora biti jedna od sljedećih vrijednosti: ${values}",
  notOneOf: "${path} ne smije biti jedna od sljedećih vrijednosti: ${values}",
  notType: function notType3(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " mora biti tipa `" + type + "`" + (" ali konačna vrijednost bila je: `" + printValue(value, true) + "`") + (isCast ? " (pretvoreno iz vrijednosti `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\nAko je "null" namijenjen kao prazna vrijednost, obavezno označite shemu kao `.nullable()`';
    }
    return msg;
  }
};
var string$2 = {
  length: "${path} mora imati tačno ${length} karaktera",
  min: "${path} mora imati najmanje ${min} karaktera",
  max: "${path} mora imati najviše ${max} karaktera",
  matches: '${path} mora odgovarati sljedećem: "${regex}"',
  email: "${path} mora biti važeća email adresa",
  url: "${path} mora biti važeći URL",
  uuid: "${path} mora biti važeći UUID",
  trim: "${path} mora biti obrezan niz znakova",
  lowercase: "${path} mora biti niz znakova malim slovima",
  uppercase: "${path} mora biti niz znakova velikim slovima"
};
var number$2 = {
  min: "${path} mora biti veći ili jednak ${min}",
  max: "${path} mora biti manji ili jednak ${max}",
  lessThan: "${path} mora biti manje od ${less}",
  moreThan: "${path} mora biti veće od ${more}",
  positive: "${path} mora biti pozitivan broj",
  negative: "${path} mora biti negativan broj",
  integer: "${path} mora biti cijeli broj"
};
var date$2 = {
  min: "${path} polje mora biti kasnije od ${min}",
  max: "${path} polje mora biti ranije od ${max}"
};
var _boolean$2 = {
  isValue: "${path} polje mora biti ${value}"
};
var object$2 = {
  noUnknown: "${path} polje ne smije imati ključeve koji nisu navedeni u obliku objekta"
};
var array$2 = {
  min: "${path} polje mora imati najmanje ${min} stavki",
  max: "${path} polje mora imati najviše ${max} stavki",
  length: "${path} mora imati ${length} stavki"
};
var bs = {
  __proto__: null,
  mixed: mixed$2,
  string: string$2,
  number: number$2,
  date: date$2,
  boolean: _boolean$2,
  object: object$2,
  array: array$2
};
var mixed$3 = {
  "default": "${path} je neplatný.",
  required: "${path} je požadované pole",
  defined: "${path} Musí být definováno",
  notNull: "${path} nemůže být null",
  oneOf: "${path} musí být jednou z následujících hodnot: ${values}",
  notOneOf: "${path} nesmí být jednou z následujících hodnot: ${values}",
  notType: function notType4(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " musí být typ `" + type + "`, " + ("Ale konečná hodnota byla: `" + printValue(value, true) + "`") + (isCast ? " (obsazení z hodnoty `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += "\n Pokud je „null“ určen jako prázdná hodnota, nezapomeňte schéma označit jako `.nullable()`";
    }
    return msg;
  }
};
var string$3 = {
  length: "${path} musí být přesně ${length} znaky",
  min: "${path} musí být alespoň ${min} znaky",
  max: "${path} musí být nejvýše ${max} znaky",
  matches: "${path} musí odpovídat následujícím: „${regex}“",
  email: "${path} Musí to být platný e-mail",
  url: "${path} musí být platná adresa URL",
  uuid: "${path} musí být platný uuid",
  trim: "${path} musí být oříznutá řetězec",
  lowercase: "${path} Musí to být řetězec s malým písmenem",
  uppercase: "${path} Musí to být řetězec horního pouzdra"
};
var number$3 = {
  min: "${path} musí být větší nebo roven ${min}",
  max: "${path} musí být menší nebo roven ${max}",
  lessThan: "${path} musí být menší než ${less}",
  moreThan: "${path} musí být větší než ${more}",
  positive: "${path} musí být kladné číslo",
  negative: "${path} musí být záporné číslo",
  integer: "${path} musí být celé číslo"
};
var date$3 = {
  min: "${path} Pole musí být později než ${min}",
  max: "${path} Pole musí být dříve než ${max}"
};
var _boolean$3 = {
  isValue: "${path} Pole musí být ${value}"
};
var object$3 = {
  noUnknown: "${path} Pole nemůže mít klíče, které nejsou uvedeny ve tvaru objektu"
};
var array$3 = {
  min: "${path} Pole musí mít alespoň ${min} položky",
  max: "${path} Pole musí mít menší nebo rovné položky ${max}",
  length: "${path} Musí mít ${length} položky"
};
var cs = {
  __proto__: null,
  mixed: mixed$3,
  string: string$3,
  number: number$3,
  date: date$3,
  boolean: _boolean$3,
  object: object$3,
  array: array$3
};
var mixed$4 = {
  "default": "${path} er ugyldig.",
  required: "${path} er et påkrævet felt",
  defined: "${path} skal defineres",
  notNull: "${path} kan ikke være null",
  oneOf: "${path} skal være en af følgende værdier: ${values}",
  notOneOf: "${path} må ikke være en af følgende værdier: ${values}",
  notType: function notType5(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " skal være en `" + type + " 'type, " + ("Men den endelige værdi var: `" + printValue(value, true) + "`") + (isCast ? " (kastet fra værdien `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Hvis "null" er beregnet til en tom værdi, skal du sørge for at markere skemaet som `.nullable()`';
    }
    return msg;
  }
};
var string$4 = {
  length: "${path} skal være nøjagtigt ${length} tegn",
  min: "${path} skal være mindst ${min} tegn",
  max: "${path} skal højst være ${max} tegn",
  matches: '${path} skal matche følgende: "${regex}"',
  email: "${path} skal være en gyldig e-mail",
  url: "${path} skal være en gyldig URL",
  uuid: "${path} skal være en gyldig UUID",
  trim: "${path} skal være en trimmet streng",
  lowercase: "${path} skal være en lille strenghed",
  uppercase: "${path} skal være en store bogstaver"
};
var number$4 = {
  min: "${path} skal være større end eller lig med ${min}",
  max: "${path} skal være mindre end eller lig med ${max}",
  lessThan: "${path} skal være mindre end ${less}",
  moreThan: "${path} skal være større end ${more}",
  positive: "${path} skal være et positivt tal",
  negative: "${path} skal være et negativt tal",
  integer: "${path} skal være et heltal"
};
var date$4 = {
  min: "${path} felt skal være senere end ${min}",
  max: "${path} felt skal være tidligere end ${max}"
};
var _boolean$4 = {
  isValue: "${path} felt skal være ${value}"
};
var object$4 = {
  noUnknown: "${path} felt kan ikke have nøgler, der ikke er specificeret i objektformen"
};
var array$4 = {
  min: "${path} felt skal have mindst ${min} genstande",
  max: "${path} felt skal have mindre end eller lig med ${max} genstande",
  length: "${path} skal have ${length} genstande"
};
var da = {
  __proto__: null,
  mixed: mixed$4,
  string: string$4,
  number: number$4,
  date: date$4,
  boolean: _boolean$4,
  object: object$4,
  array: array$4
};
var mixed$5 = {
  "default": "${path} ist ungültig.",
  required: "${path} ist ein Pflichtfeld",
  defined: "${path} muss definiert werden",
  notNull: "${path} darf nicht leer sein",
  oneOf: "${path} muss einer der folgenden Werte sein: ${values}",
  notOneOf: "${path} darf nicht einer der folgenden Werte sein: ${values}",
  notType: function notType6(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " muss ein `" + type + "` Typ sein, " + ("Aber der Endwert war: `" + printValue(value, true) + "`") + (isCast ? " (aus dem Wert `" + printValue(originalValue, true) + "` `)." : ".");
    if (value === null) {
      msg += '\n Wenn "null" als leerer Wert gedacht ist, markieren Sie das Schema als `.nullable()`';
    }
    return msg;
  }
};
var string$5 = {
  length: "${path} muss genau ${length} Zeichen lang sein",
  min: "${path} muss mindestens ${min} Zeichen lang sein",
  max: "${path} darf höchstens ${max} Zeichen lang sein",
  matches: '${path} muss folgendes Muster haben: "${regex}"',
  email: "${path} muss eine gültige E-Mail-Adresse sein",
  url: "${path} muss eine gültige URL sein",
  uuid: "${path} muss eine gültige UUID sein",
  trim: "${path} muss eine Zeichenfolge ohne Leerzeichen sein",
  lowercase: "${path} muss in Kleinbuchstaben geschrieben sein",
  uppercase: "${path} muss in Großbuchstaben geschrieben sein"
};
var number$5 = {
  min: "${path} muss größer oder gleich ${min} sein",
  max: "${path} muss geringer oder gleich ${max} sein",
  lessThan: "${path} muss kleiner als ${less} sein",
  moreThan: "${path} muss größer als ${more} sein",
  positive: "${path} muss eine positive Zahl sein",
  negative: "${path} muss eine negative Zahl sein",
  integer: "${path} muss eine ganze Zahl sein"
};
var date$5 = {
  min: "${path} muss nach ${min} sein",
  max: "${path} muss vor ${max} sein"
};
var _boolean$5 = {
  isValue: "${path} muss ${value} sein"
};
var object$5 = {
  noUnknown: "${path} kann keine unbekannten Werte enthalten"
};
var array$5 = {
  min: "${path} muss mindestens ${min} Einträge haben",
  max: "${path} darf höchstens ${max} Einträge haben",
  length: "${path} muss ${length} Einträge haben"
};
var de = {
  __proto__: null,
  mixed: mixed$5,
  string: string$5,
  number: number$5,
  date: date$5,
  boolean: _boolean$5,
  object: object$5,
  array: array$5
};
var mixed$6 = {
  "default": "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: function notType7(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " must be a `" + type + "` type, " + ("but the final value was: `" + printValue(value, true) + "`") + (isCast ? " (cast from the value `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n If "null" is intended as an empty value be sure to mark the schema as `.nullable()`';
    }
    return msg;
  }
};
var string$6 = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
var number$6 = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
var date$6 = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
var object$6 = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
var array$6 = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
var _boolean$6 = {
  isValue: "${path} field must be ${value}"
};
var en = {
  __proto__: null,
  mixed: mixed$6,
  string: string$6,
  number: number$6,
  date: date$6,
  object: object$6,
  array: array$6,
  boolean: _boolean$6
};
var mixed$7 = {
  "default": "${path} no es válido.",
  required: "${path} es un campo requerido",
  defined: "${path} debe definirse",
  notNull: "${path} no puede ser nulo",
  oneOf: "${path} debe ser uno de los siguientes valores: ${values}",
  notOneOf: "${path} no debe ser uno de los siguientes valores: ${values}",
  notType: function notType8(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " debe ser un `" + type + "` Tipo, " + ("Pero el valor final fue: `" + printValue(value, true) + "`") + (isCast ? " (Eche el valor `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Si "nulo" está destinado a ser un valor vacío, asegúrese de marcar el esquema como `.nullable()`';
    }
    return msg;
  }
};
var string$7 = {
  length: "${path} debe ser exactamente ${length} caracteres",
  min: "${path} debe ser al menos ${min} caracteres",
  max: "${path} debe ser como máximo ${max} caracteres",
  matches: '${path} debe coincidir con lo siguiente: "${regex}"',
  email: "${path} debe ser un correo electrónico válido",
  url: "${path} debe ser una URL válida",
  uuid: "${path} debe ser un UUID válido",
  trim: "${path} debe ser una cadena recortada",
  lowercase: "${path} debe ser una cadena en minúscula",
  uppercase: "${path} debe ser una cadena de casos superiores"
};
var number$7 = {
  min: "${path} debe ser mayor o igual a ${min}",
  max: "${path} debe ser menor o igual a ${max}",
  lessThan: "${path} debe ser menor que ${less}",
  moreThan: "${path} debe ser mayor que ${more}",
  positive: "${path} debe ser un número positivo",
  negative: "${path} debe ser un número negativo",
  integer: "${path} debe ser un entero"
};
var date$7 = {
  min: "${path} El campo debe ser más tarde que ${min}",
  max: "${path} El campo debe estar antes de ${max}"
};
var _boolean$7 = {
  isValue: "${path} El campo debe ser ${value}"
};
var object$7 = {
  noUnknown: "${path} el campo no puede tener claves no especificadas en la forma del objeto"
};
var array$7 = {
  min: "${path} el campo debe tener al menos ${min} elementos",
  max: "${path} El campo debe tener menos o igual a los elementos ${max}",
  length: "${path} debe tener ${length} elementos"
};
var es = {
  __proto__: null,
  mixed: mixed$7,
  string: string$7,
  number: number$7,
  date: date$7,
  boolean: _boolean$7,
  object: object$7,
  array: array$7
};
var mixed$8 = {
  "default": "${path} n'est pas valide.",
  required: "${path} est un champ requis",
  defined: "${path} doit être défini",
  notNull: "${path} ne peut pas être nul",
  oneOf: "${path} doit être l'une des valeurs suivantes: ${values}",
  notOneOf: "${path} ne doit pas être l'une des valeurs suivantes: ${values}",
  notType: function notType9(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " doit être un type `" + type + "`, " + ("Mais la valeur finale était: `" + printValue(value, true) + "`") + (isCast ? " (coulé à partir de la valeur `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Si "null" est conçu comme une valeur vide, assurez-vous de marquer le schéma comme `.nullable()`';
    }
    return msg;
  }
};
var string$8 = {
  length: "${path} doit être exactement ${length} caractères",
  min: "${path} doit être au moins ${min} caractères",
  max: "${path} doit être au plus ${max} caractères",
  matches: '${path} doit correspondre à ce qui suit: "${regex}"',
  email: "${path} doit être un e-mail valide",
  url: "${path} doit être une URL valide",
  uuid: "${path} doit être un uuid valide",
  trim: "${path} doit être une chaîne taillée",
  lowercase: "${path} doit être une chaîne en minuscules",
  uppercase: "${path} Doit être une chaîne en majuscules"
};
var number$8 = {
  min: "${path} doit être supérieur ou égal à ${min}",
  max: "${path} doit être inférieur ou égal à ${max}",
  lessThan: "${path} doit être inférieur à ${less}",
  moreThan: "${path} doit être supérieur à ${more}",
  positive: "${path} doit être un nombre positif",
  negative: "${path} doit être un nombre négatif",
  integer: "${path} doit être un entier"
};
var date$8 = {
  min: "${path} Le champ doit être plus tard que ${min}",
  max: "${path} Le champ doit être plus tôt que ${max}"
};
var _boolean$8 = {
  isValue: "${path} Le champ doit être ${value}"
};
var object$8 = {
  noUnknown: "${path} Le champ ne peut pas avoir des clés non spécifiées dans la forme de l'objet"
};
var array$8 = {
  min: "${path} Le champ doit avoir au moins ${min} des articles",
  max: "${path} Le champ doit avoir moins ou égal à ${max}",
  length: "${path} doit avoir ${length} des articles"
};
var fr = {
  __proto__: null,
  mixed: mixed$8,
  string: string$8,
  number: number$8,
  date: date$8,
  boolean: _boolean$8,
  object: object$8,
  array: array$8
};
var mixed$9 = {
  "default": "${path} אינו חוקי.",
  required: "${path} הוא שדה חובה",
  defined: "${path} חייב להיות מוגדר",
  notNull: "${path} לא יכול להיות null",
  oneOf: "${path} חייב להיות אחד הערכים הבאים: ${values}",
  notOneOf: "${path} אסור להיות אחד הערכים הבאים: ${values}",
  notType: function notType10(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " חייב להיות סוג '" + type + "' סוג, " + ("אבל הערך הסופי היה: `" + printValue(value, true) + "`") + (isCast ? " (יצוק מהערך `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n אם "null" מיועד כערך ריק, הקפד לסמן את הסכימה כ- `.nullable()`';
    }
    return msg;
  }
};
var string$9 = {
  length: "${path} חייב להיות בדיוק ${length} תווים",
  min: "${path} חייב להיות לפחות ${min} תווים",
  max: "${path} חייב להיות לכל היותר ${max} תווים",
  matches: '${path} חייב להתאים לדברים הבאים: "${regex}"',
  email: '${path} חייב להיות דוא"ל תקף',
  url: "${path} חייב להיות כתובת אתר תקפה",
  uuid: "${path} חייב להיות UUID תקף",
  trim: "${path} חייב להיות מחרוזת גזומה",
  lowercase: "${path} חייב להיות מחרוזת אותיות קטנות",
  uppercase: "${path} חייב להיות מחרוזת אותיות עליונות"
};
var number$9 = {
  min: "${path} חייב להיות גדול או שווה ל- ${min}",
  max: "${path} חייב להיות פחות או שווה ל- ${max}",
  lessThan: "${path} חייב להיות פחות מ- ${less}",
  moreThan: "${path} חייב להיות גדול מ- ${more}",
  positive: "${path} חייב להיות מספר חיובי",
  negative: "${path} חייב להיות מספר שלילי",
  integer: "${path} חייב להיות מספר שלם"
};
var date$9 = {
  min: "שדה ${path} חייב להיות מאוחר יותר מ- ${min}",
  max: "שדה ${path} חייב להיות מוקדם יותר מ- ${max}"
};
var _boolean$9 = {
  isValue: "שדה ${path} חייב להיות ${value}"
};
var object$9 = {
  noUnknown: "${path} שדה לא יכול להיות בעל מפתחות שלא צוינו בצורת האובייקט"
};
var array$9 = {
  min: "שדה ${path} חייב להיות לפחות פריטים ${min}",
  max: "שדה ${path} חייב להיות פחות או שווה לפריטים ${max}",
  length: "${path} חייב להיות ${length} פריטים"
};
var he = {
  __proto__: null,
  mixed: mixed$9,
  string: string$9,
  number: number$9,
  date: date$9,
  boolean: _boolean$9,
  object: object$9,
  array: array$9
};
var mixed$a = {
  "default": "A ${path} érvénytelen.",
  required: "A ${path} egy szükséges mező",
  defined: "${path} meg kell határozni",
  notNull: "${path} nem lehet nulla",
  oneOf: "${path} a következő értékek egyikének kell lennie: ${values}",
  notOneOf: "${path} nem lehet a következő értékek egyike: ${values}",
  notType: function notType11(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + ' "' + type + '" típusnak kell lennie, ' + ("De a végső érték a következő volt: `" + printValue(value, true) + "`") + (isCast ? " (a „" + printValue(originalValue, true) + "” értékből öntött)." : ".");
    if (value === null) {
      msg += '\n Ha a "null" üres értéknek szánják, feltétlenül jelölje meg a sémát `.nullable()`';
    }
    return msg;
  }
};
var string$a = {
  length: "${path} pontosan ${length} karaktereknek kell lennie",
  min: "${path} legalább ${min} karaktereknek kell lennie",
  max: "${path} legfeljebb ${max} karaktereknek kell lennie",
  matches: '${path} meg kell egyeznie a következőkkel: "${regex}"',
  email: "${path} érvényes e -mailnek kell lennie",
  url: "${path} érvényes URL -nek kell lennie",
  uuid: "${path} érvényes UUID -nak kell lennie",
  trim: "A ${path} -nak vágott karakterláncnak kell lennie",
  lowercase: "${path} kisbetűs karakterláncnak kell lennie",
  uppercase: "A ${path} -nak felsőfokú karakterláncnak kell lennie"
};
var number$a = {
  min: "${path} nagyobbnak vagy egyenlőnek kell lennie ${min}",
  max: "A ${path} -nak kevesebbnek vagy egyenlőnek kell lennie ${max}",
  lessThan: "A ${path} -nak kevesebbnek kell lennie, mint a ${less}",
  moreThan: "${path} nagyobbnak kell lennie, mint a ${more}",
  positive: "${path} pozitív számnak kell lennie",
  negative: "${path} negatív számnak kell lennie",
  integer: "${path} egész számnak kell lennie"
};
var date$a = {
  min: "${path} A mezőnek később kell lennie, mint a ${min}",
  max: "${path} A mezőnek korábban kell lennie, mint a ${max}"
};
var _boolean$a = {
  isValue: "${path} A mezőnek ${value} -nak kell lennie"
};
var object$a = {
  noUnknown: "${path} A mezőnek nem lehet olyan kulcsok, amelyek nem adják meg az objektum alakjában"
};
var array$a = {
  min: "${path} A mezőnek legalább ${min} tételekkel kell rendelkeznie",
  max: "${path} A mezőnek kevesebbnek vagy egyenlőnek kell lennie a ${max} tételekkel",
  length: "${path} ${length} tételekkel kell rendelkeznie"
};
var hu = {
  __proto__: null,
  mixed: mixed$a,
  string: string$a,
  number: number$a,
  date: date$a,
  boolean: _boolean$a,
  object: object$a,
  array: array$a
};
var mixed$b = {
  "default": "${path} tidak valid.",
  required: "${path} adalah bidang yang diperlukan",
  defined: "${path} harus didefinisikan",
  notNull: "${path} tidak bisa nol",
  oneOf: "${path} harus menjadi salah satu dari nilai -nilai berikut: ${values}",
  notOneOf: "${path} tidak boleh menjadi salah satu dari nilai -nilai berikut: ${values}",
  notType: function notType12(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " harus `" + type + "` tipe, " + ("tetapi nilai akhir adalah: `" + printValue(value, true) + "`") + (isCast ? " (dilemparkan dari nilai `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Jika "null" dimaksudkan sebagai nilai kosong, pastikan untuk menandai skema sebagai `.nullable()`';
    }
    return msg;
  }
};
var string$b = {
  length: "${path} harus persis ${length} karakter",
  min: "${path} harus setidaknya ${min} karakter",
  max: "${path} harus paling banyak ${max} karakter",
  matches: '${path} harus cocok dengan yang berikut: "${regex}"',
  email: "${path} harus menjadi email yang valid",
  url: "${path} harus menjadi URL yang valid",
  uuid: "${path} harus menjadi UUID yang valid",
  trim: "${path} harus menjadi string yang dipangkas",
  lowercase: "${path} harus menjadi string kecil",
  uppercase: "${path} Harus menjadi string kasus atas"
};
var number$b = {
  min: "${path} harus lebih besar dari atau sama dengan ${min}",
  max: "${path} harus kurang dari atau sama dengan ${max}",
  lessThan: "${path} harus kurang dari ${less}",
  moreThan: "${path} harus lebih besar dari ${more}",
  positive: "${path} harus menjadi angka positif",
  negative: "${path} harus menjadi angka negatif",
  integer: "${path} harus menjadi bilangan bulat"
};
var date$b = {
  min: "${path} Bidang harus lebih lambat dari ${min}",
  max: "${path} Lapangan harus lebih awal dari ${max}"
};
var _boolean$b = {
  isValue: "${path} Bidang harus ${value}"
};
var object$b = {
  noUnknown: "${path} Bidang tidak dapat memiliki kunci yang tidak ditentukan dalam bentuk objek"
};
var array$b = {
  min: "${path} Bidang harus memiliki setidaknya ${min} item",
  max: "${path} Lapangan harus memiliki kurang dari atau sama dengan item ${max}",
  length: "${path} harus memiliki item ${length}"
};
var id = {
  __proto__: null,
  mixed: mixed$b,
  string: string$b,
  number: number$b,
  date: date$b,
  boolean: _boolean$b,
  object: object$b,
  array: array$b
};
var mixed$c = {
  "default": "${path} non è valido.",
  required: "${path} è un campo richiesto",
  defined: "${path} deve essere definito",
  notNull: "${path} non può essere nullo",
  oneOf: "${path} deve essere uno dei seguenti valori: ${values}",
  notOneOf: "${path} non deve essere uno dei seguenti valori: ${values}",
  notType: function notType13(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " deve essere un tipo `" + type + "`, " + ("Ma il valore finale era: `" + printValue(value, true) + "`") + (isCast ? " (cast dal valore `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Se "null" è inteso come valore vuoto, assicurarsi di contrassegnare lo schema come `.nullable()`';
    }
    return msg;
  }
};
var string$c = {
  length: "${path} deve essere esattamente ${length} caratteri",
  min: "${path} deve essere almeno ${min} caratteri",
  max: "${path} deve essere al massimo ${max} caratteri",
  matches: '${path} deve abbinare quanto segue: "${regex}"',
  email: "${path} deve essere un'e-mail valida",
  url: "${path} deve essere un URL valido",
  uuid: "${path} deve essere un uuid valido",
  trim: "${path} deve essere una stringa tagliata",
  lowercase: "${path} deve essere una stringa minuscola",
  uppercase: "${path} deve essere una stringa maiuscola"
};
var number$c = {
  min: "${path} deve essere maggiore o uguale a ${min}",
  max: "${path} deve essere inferiore o uguale a ${max}",
  lessThan: "${path} deve essere inferiore a ${less}",
  moreThan: "${path} deve essere maggiore di ${more}",
  positive: "${path} deve essere un numero positivo",
  negative: "${path} deve essere un numero negativo",
  integer: "${path} deve essere un numero intero"
};
var date$c = {
  min: "${path} Il campo deve essere successivo di ${min}",
  max: "${path} Il campo deve essere prima di ${max}"
};
var _boolean$c = {
  isValue: "${path} Il campo deve essere ${value}"
};
var object$c = {
  noUnknown: "${path} Il campo non può avere i tasti non specificati nella forma dell'oggetto"
};
var array$c = {
  min: "${path} Il campo deve avere almeno ${min} articoli",
  max: "${path} Il campo deve avere meno o uguale a ${max} elementi",
  length: "${path} deve avere ${length} articoli"
};
var it = {
  __proto__: null,
  mixed: mixed$c,
  string: string$c,
  number: number$c,
  date: date$c,
  boolean: _boolean$c,
  object: object$c,
  array: array$c
};
var mixed$d = {
  "default": function _default(_ref) {
    var path = _ref.path;
    return path + "は正しくありません。";
  },
  required: function required(_ref2) {
    var path = _ref2.path;
    return path + "が必要です。";
  },
  defined: function defined(_ref3) {
    var path = _ref3.path;
    return path + "をundefinedにすることはできません。";
  },
  oneOf: function oneOf(_ref4) {
    var path = _ref4.path, values = _ref4.values;
    return path + "は" + values + "の中から入力してください。";
  },
  notOneOf: function notOneOf(_ref5) {
    var path = _ref5.path, values = _ref5.values;
    return path + "は" + values + "意外入力してください。";
  },
  notType: function notType14(_ref6) {
    var path = _ref6.path, type = _ref6.type, value = _ref6.value, originalValue = _ref6.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + "が`" + type + "`ではありません、, " + ("しかし、最終的な値は: `" + printValue(value, true) + "`") + (isCast ? " (`" + printValue(originalValue, true) + "`)値からキャストする。" : ".");
    if (value === null) {
      msg += "\n「null」が空の値として意図されている場合は、必ずスキーマを`.nullable()`に設定してください。 ";
    }
    return msg;
  }
};
var string$d = {
  length: function length(_ref7) {
    var path = _ref7.path, _length = _ref7.length;
    return path + "は" + _length + "文字の文字列である必要があります。";
  },
  min: function min(_ref8) {
    var path = _ref8.path, _min = _ref8.min;
    return path + "は" + _min + "文字以上の文字列である必要があります。";
  },
  max: function max(_ref9) {
    var path = _ref9.path, _max = _ref9.max;
    return path + "は" + _max + "文字以下の文字列である必要があります。";
  },
  matches: function matches(_ref10) {
    var path = _ref10.path;
    return path + "の入力形式が間違っています。";
  },
  email: function email(_ref11) {
    var path = _ref11.path;
    return path + "はメールの形式で入力してください。";
  },
  url: function url(_ref12) {
    var path = _ref12.path;
    return path + "はURLの形式で入力してください。";
  },
  uuid: function uuid(_ref13) {
    var path = _ref13.path;
    return path + "はUUIDの形式で入力してください。";
  },
  trim: function trim(_ref14) {
    var path = _ref14.path;
    return path + "はトリミングされた文字列である必要があります。";
  },
  lowercase: function lowercase(_ref15) {
    var path = _ref15.path;
    return path + "は小文字の文字列である必要があります。";
  },
  uppercase: function uppercase(_ref16) {
    var path = _ref16.path;
    return path + "は大文字の文字列である必要があります。";
  }
};
var number$d = {
  min: function min2(_ref17) {
    var path = _ref17.path, _min2 = _ref17.min;
    return path + "は" + _min2 + "以上の数値である必要があります。";
  },
  max: function max2(_ref18) {
    var path = _ref18.path, _max2 = _ref18.max;
    return path + "は" + _max2 + "以下の数値である必要があります。";
  },
  lessThan: function lessThan(_ref19) {
    var path = _ref19.path, less = _ref19.less;
    return path + "は" + less + "より小さな数値である必要があります。";
  },
  moreThan: function moreThan(_ref20) {
    var path = _ref20.path, more = _ref20.more;
    return path + "は" + more + "より大きな数値である必要があります。";
  },
  positive: function positive(_ref21) {
    var path = _ref21.path, more = _ref21.more;
    return path + "は" + more + "より小さな数値である必要があります。";
  },
  negative: function negative(_ref22) {
    var path = _ref22.path, less = _ref22.less;
    return path + "は" + less + "より大きな数値である必要があります。";
  },
  integer: function integer(_ref23) {
    var path = _ref23.path;
    return path + "は整数である必要があります。";
  }
};
var date$d = {
  min: function min3(_ref24) {
    var path = _ref24.path, _min3 = _ref24.min;
    return path + "は" + _min3 + "以降の日時である必要があります。";
  },
  max: function max3(_ref25) {
    var path = _ref25.path, _max3 = _ref25.max;
    return path + "は" + _max3 + "以前の日時である必要があります。";
  }
};
var _boolean$d = {};
var object$d = {
  noUnknown: function noUnknown(_ref26) {
    var path = _ref26.path;
    return path + "フィールドにオブジェクトで指定されていないキーを含めることはできません。";
  }
};
var array$d = {
  min: function min4(_ref27) {
    var path = _ref27.path, _min4 = _ref27.min;
    return path + "に" + _min4 + "個以上の要素である必要があります。";
  },
  max: function max4(_ref28) {
    var path = _ref28.path, _max4 = _ref28.max;
    return path + "に" + _max4 + "個以下の要素である必要があります。";
  }
};
var ja = {
  __proto__: null,
  mixed: mixed$d,
  string: string$d,
  number: number$d,
  date: date$d,
  boolean: _boolean$d,
  object: object$d,
  array: array$d
};
var mixed$e = {
  "default": "${path} 항목이 올바르지 않습니다.",
  required: "${path} 항목은 필수입니다.",
  defined: "${path} 항목 값이 정의되어야 합니다.",
  notNull: "${path} 항목은 null일수 없습니다.",
  oneOf: "${path} 항목은 다음 값중 하나여야 합니다: ${values}",
  notOneOf: "${path} 항목은 다음 값이 아니여야 합니다: ${values}",
  notType: function notType15(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var castMsg = originalValue != null && originalValue !== value ? " (`" + printValue(originalValue, true) + "` 값에서 캐스팅)." : ".";
    return type !== "mixed" ? path + " 항목은 `" + type + "` 타입이 필요한데, " + ("최종 값은: `" + printValue(value, true) + "`") + castMsg : path + " 항목은 구성된 타입과 일치해야 합니다. " + ("검증 값은: `" + printValue(value, true) + "`") + castMsg;
  }
};
var string$e = {
  length: "${path} 항목은 ${length} 글자여야 합니다.",
  min: "${path} 항목은 ${min} 글자이상이여야 합니다.",
  max: "${path} 항목은 ${max} 글자이하여야 합니다.",
  matches: '${path} 항목의 형식이 올바르지 않습니다: "${regex}"',
  email: "${path} 항목은 이메일형식이여야 합니다.",
  url: "${path} 항목은 URL형식이여야 합니다.",
  uuid: "${path} 항목은 UUID형식이여야 합니다.",
  trim: "${path} 항목은 압뒤공백이 없어야 합니다",
  lowercase: "${path} 항목은 소문자여야 합니다.",
  uppercase: "${path} 항목은 대문자여야 합니다."
};
var number$e = {
  min: "${path} 항목은 ${min} 이상이여야 합니다.",
  max: "${path} 항목은 ${max} 이하여야 합니다.",
  lessThan: "${path} 항목은 ${less} 미만이여야 합니다.",
  moreThan: "${path} 항목은 ${more} 초과여야 합니다.",
  positive: "${path} 항목은 양수여야 합니다.",
  negative: "${path} 항목은 음수여야 합니다.",
  integer: "${path} 항목은 정수여야 합니다."
};
var date$e = {
  min: "${path} 항목은 ${min} 이후여야 합니다.",
  max: "${path} 항목은 ${max} 이전이여야 합니다."
};
var _boolean$e = {
  isValue: "${path} 항목은 ${value}여야 합니다."
};
var object$e = {
  noUnknown: "${path} 항목에 지정되지 않은 키가 있습니다: ${unknown}"
};
var array$e = {
  min: "${path} 항목의 아이템은 ${min}개 이상이여야 합니다.",
  max: "${path} 항목의 아이템은 ${max}개 이하여야 합니다.",
  length: "${path} 항목의 아이템은 ${length}개여야 합니다."
};
var ko = {
  __proto__: null,
  mixed: mixed$e,
  string: string$e,
  number: number$e,
  date: date$e,
  boolean: _boolean$e,
  object: object$e,
  array: array$e
};
var mixed$f = {
  "default": "${path} neteisinga.",
  required: "${path} yra būtinas laukas",
  defined: "Turi būti apibrėžtas ${path}",
  notNull: "${path} negali būti niekinis",
  oneOf: "${path} turi būti viena iš šių verčių: ${values}",
  notOneOf: "${path} neturi būti viena iš šių verčių: ${values}",
  notType: function notType16(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " turi būti `" + type + "` tipas, " + ("Bet galutinė vertė buvo: `" + printValue(value, true) + "`") + (isCast ? " (Išmeskite iš vertės `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += "\n Jei „null“ yra skirta kaip tuščia vertė, būtinai pažymėkite schemą kaip `.nullable()`";
    }
    return msg;
  }
};
var string$f = {
  length: "${path} turi būti tiksliai ${length} simboliai",
  min: "${path} turi būti bent ${min} simboliai",
  max: "${path} turi būti daugiausia ${max} simbolių",
  matches: "${path} turi atitikti šiuos dalykus: „${regex}“",
  email: "${path} turi būti galiojantis el. Laiškas",
  url: "${path} turi būti galiojantis URL",
  uuid: "${path} turi būti galiojantis UUID",
  trim: "${path} turi būti apipjaustyta styga",
  lowercase: "${path} turi būti mažosios raidės",
  uppercase: "${path} turi būti didžiosios raidės eilutė"
};
var number$f = {
  min: "${path} turi būti didesnis arba lygus ${min}",
  max: "${path} turi būti mažesnis arba lygus ${max}",
  lessThan: "${path} turi būti mažesnis nei ${less}",
  moreThan: "${path} turi būti didesnis nei ${more}",
  positive: "${path} turi būti teigiamas skaičius",
  negative: "${path} turi būti neigiamas skaičius",
  integer: "${path} turi būti sveikasis skaičius"
};
var date$f = {
  min: "${path} Laukas turi būti vėliau nei ${min}",
  max: "${path} Laukas turi būti anksčiau nei ${max}"
};
var _boolean$f = {
  isValue: "${path} Laukas turi būti ${value}"
};
var object$f = {
  noUnknown: "${path} Lauke negali būti raktų, nenurodytų objekto formoje"
};
var array$f = {
  min: "${path} Lauke turi būti bent ${min} elementai",
  max: "${path} Lauke turi būti mažesnis arba lygus ${max} elementams",
  length: "${path} turi turėti ${length} elementus"
};
var lt = {
  __proto__: null,
  mixed: mixed$f,
  string: string$f,
  number: number$f,
  date: date$f,
  boolean: _boolean$f,
  object: object$f,
  array: array$f
};
var mixed$g = {
  "default": "${path} er ugyldig",
  required: "${path} er et påkrevd felt",
  defined: "${path} må defineres",
  notNull: "${path} kan ikke være null",
  oneOf: "${path} må være en av følgende verdier: ${values}",
  notOneOf: "${path} må ikke være en av følgende verdier: ${values}",
  notType: function notType17(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " må være en `" + type + "` type, " + ("men den endelige verdien var: `" + printValue(value, true) + "`") + (isCast ? " (støpt fra verdien `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Hvis "null" er ment som en tom verdi, må du huske å markere skjemaet som `.nullable()`';
    }
    return msg;
  }
};
var string$g = {
  length: "${path} må være nøyaktig ${length} tegn",
  min: "${path} må være minst ${min} tegn",
  max: "${path} må være på det meste ${max} tegn",
  matches: '${path} må samsvare med følgende: "${regex}"',
  email: "${path} må være en gyldig e-post",
  url: "${path} må være en gyldig URL",
  uuid: "${path} må være en gyldig UUID",
  trim: "${path} må være en trimmet streng",
  lowercase: "${path} må være små bokstaver",
  uppercase: "${path} må være store bokstaver"
};
var number$g = {
  min: "${path} må være større enn eller lik ${min}",
  max: "${path} må være mindre enn eller lik ${max}",
  lessThan: "${path} må være mindre enn ${less}",
  moreThan: "${path} må være større enn ${more}",
  positive: "${path} må være et positivt tall",
  negative: "${path} må være et negativt tall",
  integer: "${path} må være et heltall"
};
var date$g = {
  min: "${path} feltet må være senere enn ${min}",
  max: "${path} feltet må være tidligere enn ${max}"
};
var _boolean$g = {
  isValue: "${path} feltet må være ${value}"
};
var object$g = {
  noUnknown: "${path} felt kan ikke ha nøkler som ikke er spesifisert i objektformen"
};
var array$g = {
  min: "${path} feltet må ha minst ${min} elementer",
  max: "${path} feltet må ha mindre enn eller lik ${max} elementer",
  length: "${path} må ha ${length} elementer"
};
var nb = {
  __proto__: null,
  mixed: mixed$g,
  string: string$g,
  number: number$g,
  date: date$g,
  boolean: _boolean$g,
  object: object$g,
  array: array$g
};
var mixed$h = {
  "default": "${path} is ongeldig.",
  required: "${path} is een vereist veld",
  defined: "${path} moet worden gedefinieerd",
  notNull: "${path} kan niet leeg zijn",
  oneOf: "${path} moet een van de volgende waarden zijn: ${values}",
  notOneOf: "${path} mag niet een van de volgende waarden zijn: ${values}",
  notType: function notType18(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " moet een `" + type + "` type zijn, " + ("maar de uiteindelijke waarde was: `" + printValue(value, true) + "`") + (isCast ? " (gegoten uit de waarde `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Als "null" bedoeld is als een lege waarde, moet u het schema markeren als `.nullable()`';
    }
    return msg;
  }
};
var string$h = {
  length: "${path} moet precies ${length} tekens zijn",
  min: "${path} moet op zijn minst ${min} tekens zijn",
  max: "${path} moet maximaal ${max} tekens zijn",
  matches: '${path} moet overeenkomen met: "${regex}"',
  email: "${path} moet een geldige e-mail zijn",
  url: "${path} moet een geldige URL zijn",
  uuid: "${path} moet een geldige uuid zijn",
  trim: "${path} mag geen begin- of eindspaties bevatten",
  lowercase: "${path} mag alleen bestaan uit kleine letters",
  uppercase: "${path} mag alleen bestaan uit hoofdletters"
};
var number$h = {
  min: "${path} moet groter zijn dan of gelijk zijn aan ${min}",
  max: "${path} moet kleiner zijn dan of gelijk zijn aan ${max}",
  lessThan: "${path} moet minder zijn dan ${less}",
  moreThan: "${path} moet groter zijn dan ${more}",
  positive: "${path} moet een positief getal zijn",
  negative: "${path} moet een negatief getal zijn",
  integer: "${path} moet een geheel getal zijn"
};
var date$h = {
  min: "${path} veld moet later zijn dan ${min}",
  max: "${path} veld moet eerder zijn dan ${max}"
};
var _boolean$h = {
  isValue: "${path} veld moet ${value} zijn"
};
var object$h = {
  noUnknown: "${path} mag geen waarden bevatten die niet zijn opgegeven in het object"
};
var array$h = {
  min: "${path} veld moet ten minste ${min} items bevatten",
  max: "${path} veld mag niet meer dan ${max} items bevatten",
  length: "${path} moet ${length} items hebben"
};
var nl = {
  __proto__: null,
  mixed: mixed$h,
  string: string$h,
  number: number$h,
  date: date$h,
  boolean: _boolean$h,
  object: object$h,
  array: array$h
};
var mixed$i = {
  "default": "${path} jest nieprawidłowy.",
  required: "${path} to pole wymagane",
  defined: "${path} należy zdefiniować",
  notNull: "${path} nie może być null",
  oneOf: "${path} musi być jedną z następujących wartości: ${values}",
  notOneOf: "${path} nie może być jedną z następujących wartości: ${values}",
  notType: function notType19(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " musi być typem „" + type + "`, " + ("Ale ostateczna wartość to: `" + printValue(value, true) + "` `") + (isCast ? " (odlewana z wartości `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += "\n Jeśli „null” jest przeznaczony jako pusta wartość, pamiętaj o oznaczeniu schematu jako `.nullable()`";
    }
    return msg;
  }
};
var string$i = {
  length: "${path} musi być dokładnie ${length} znaki",
  min: "${path} musi być co najmniej ${min} znaki",
  max: "${path} musi być co najwyżej ${max} znaki",
  matches: "${path} musi dopasować następujące czynności: „${regex}”",
  email: "${path} musi być ważnym e-mailem",
  url: "${path} musi być ważnym adresem URL",
  uuid: "${path} musi być ważnym UUID",
  trim: "${path} musi być przyciętym ciągiem",
  lowercase: "${path} musi być małym sznurkiem",
  uppercase: "${path} musi być sznurkiem górnym"
};
var number$i = {
  min: "${path} musi być większy lub równy ${min}",
  max: "${path} musi być mniejsze lub równe ${max}",
  lessThan: "${path} musi być mniej niż ${less}",
  moreThan: "${path} musi być większy niż ${more}",
  positive: "${path} musi być liczbą dodatnią",
  negative: "${path} musi być liczbą ujemną",
  integer: "${path} musi być liczbą całkowitą"
};
var date$i = {
  min: "${path} pole musi być później niż ${min}",
  max: "${path} pole musi być wcześniej niż ${max}"
};
var _boolean$i = {
  isValue: "${path} pole musi być ${value}"
};
var object$i = {
  noUnknown: "${path} Pole nie może mieć kluczy nie określonych w kształcie obiektu"
};
var array$i = {
  min: "${path} pole musi mieć przynajmniej ${min} elementy",
  max: "${path} pole musi mieć mniejsze lub równe ${max} elementy",
  length: "${path} musi mieć elementy ${length}"
};
var pl = {
  __proto__: null,
  mixed: mixed$i,
  string: string$i,
  number: number$i,
  date: date$i,
  boolean: _boolean$i,
  object: object$i,
  array: array$i
};
var mixed$j = {
  "default": "${path} é inválido.",
  required: "${path} é obrigatório",
  defined: "${path} não deve ser indefinido",
  notNull: "${path} não pode ser vazio",
  oneOf: "${path} deve ter um dos seguintes valores: ${values}",
  notOneOf: "${path} não deve ter nenhum dos seguintes valores: ${values}",
  notType: function notType20(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " deve ser do tipo `" + type + "`, " + ("mas o valor final foi: `" + printValue(value, true) + "`") + (isCast ? " (cast do valor `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Se a intenção era usar "null" como um valor em branco marque o esquema como `.nullable()`';
    }
    return msg;
  }
};
var string$j = {
  length: function length2(_ref2) {
    var path = _ref2.path, _length = _ref2.length;
    return path + " deve ter exatamente " + _length + " " + (_length === 1 ? "caractere" : "caracteres");
  },
  min: function min5(_ref3) {
    var path = _ref3.path, _min = _ref3.min;
    return path + " deve ter no mínimo " + _min + " " + (_min === 1 ? "caractere" : "caracteres");
  },
  max: function max5(_ref4) {
    var path = _ref4.path, _max = _ref4.max;
    return path + " deve ter no máximo " + _max + " " + (_max === 1 ? "caractere" : "caracteres");
  },
  matches: '${path} deve corresponder ao padrão: "${regex}"',
  email: "${path} deve ser um e-mail válido",
  url: "${path} deve ser uma URL válida",
  uuid: "${path} deve ser um UUID válido",
  trim: "${path} não deve conter espaços no início nem no fim",
  lowercase: "${path} deve estar em letras minúsculas",
  uppercase: "${path} deve estar em letras maiúsculas"
};
var number$j = {
  min: "${path} deve ser maior ou igual a ${min}",
  max: "${path} deve ser menor ou igual a ${max}",
  lessThan: "${path} deve ser menor que ${less}",
  moreThan: "${path} deve ser maior que ${more}",
  positive: "${path} deve ser um número positivo",
  negative: "${path} deve ser um número negativo",
  integer: "${path} deve ser um número inteiro"
};
var date$j = {
  min: "${path} deve ser posterior a ${min}",
  max: "${path} deve ser anterior a ${max}"
};
var _boolean$j = {
  isValue: "${path} deve ser ${value}"
};
var object$j = {
  noUnknown: "${path} tem chaves desconhecidas: ${unknown}"
};
var array$j = {
  min: function min6(_ref5) {
    var path = _ref5.path, _min2 = _ref5.min;
    return path + " deve ter no mínimo " + _min2 + " " + (_min2 === 1 ? "item" : "itens");
  },
  max: function max6(_ref6) {
    var path = _ref6.path, _max2 = _ref6.max;
    return path + " deve ter no máximo " + _max2 + " " + (_max2 === 1 ? "item" : "itens");
  },
  length: function length3(_ref7) {
    var path = _ref7.path, _length2 = _ref7.length;
    return path + " deve ter " + _length2 + " " + (_length2 === 1 ? "item" : "itens");
  }
};
var pt = {
  __proto__: null,
  mixed: mixed$j,
  string: string$j,
  number: number$j,
  date: date$j,
  boolean: _boolean$j,
  object: object$j,
  array: array$j
};
var mixed$k = {
  "default": "${path} является недействительным.",
  required: "${path} - необходимое поле",
  defined: "${path} должен быть определен",
  notNull: "${path} не может быть нулевым",
  oneOf: "${path} должен быть одним из следующих значений: ${values}",
  notOneOf: "${path} не должен быть одним из следующих значений: ${values}",
  notType: function notType21(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " должен быть `" + type + "` тип, " + ("Но окончательное значение было: `" + printValue(value, true) + "`") + (isCast ? " (бросить из значения `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += "\n Если «нуль» предназначено как пустое значение, обязательно отметить схему как `.nullable()`";
    }
    return msg;
  }
};
var string$k = {
  length: "${path} должен быть точно ${length} символы",
  min: "${path} должен быть как минимум ${min} символы",
  max: "${path} должен быть не более максимум ${max} символы",
  matches: '${path} должен соответствовать следующему: "${regex}"',
  email: "${path} Должен быть действительным электронным письмом",
  url: "${path} должен быть действительный URL",
  uuid: "${path} должен быть действительным UUID",
  trim: "${path} Должен быть обрезанной строкой",
  lowercase: "${path} Должен быть строчной строкой",
  uppercase: "${path} должна быть строка верхнего чехла"
};
var number$k = {
  min: "${path} должен быть больше или равен ${min}",
  max: "${path} должно быть меньше или равна ${max}",
  lessThan: "${path} должно быть меньше, чем ${less}",
  moreThan: "${path} должен быть больше, чем ${more}",
  positive: "${path} должно быть положительным числом",
  negative: "${path} должно быть отрицательным числом",
  integer: "${path} должно быть целым числом"
};
var date$k = {
  min: "${path} Поле должно быть позже ${min}",
  max: "${path} Поле должно быть в более раннем, чем ${max}"
};
var _boolean$k = {
  isValue: "${path} Поле должно быть ${value}"
};
var object$k = {
  noUnknown: "Поле ${path} не может иметь ключи, не указанные в форме объекта"
};
var array$k = {
  min: "${path} Поле должно иметь по крайней мере ${min} элементы",
  max: "${path} Поле должно иметь меньше или равное ${max} элементам",
  length: "${path} должны иметь ${length} элементы"
};
var ru = {
  __proto__: null,
  mixed: mixed$k,
  string: string$k,
  number: number$k,
  date: date$k,
  boolean: _boolean$k,
  object: object$k,
  array: array$k
};
var mixed$l = {
  "default": "${path} je neplatný.",
  required: "${path} je požadované pole",
  defined: "${path} sa musí definovať",
  notNull: "${path} nemôže byť null",
  oneOf: "${path} musí byť jednou z nasledujúcich hodnôt: ${values}",
  notOneOf: "${path} nesmie byť jednou z nasledujúcich hodnôt: ${values}",
  notType: function notType22(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " musí byť `" + type + "`, " + ("ale konečná hodnota bola: `" + printValue(value, true) + "`") + (isCast ? " (odliatok z hodnoty `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += "\n Ak je „null“ určený ako prázdna hodnota, nezabudnite označiť schému ako `.nullable()`";
    }
    return msg;
  }
};
var string$l = {
  length: "${path} musia byť presne ${length} znaky",
  min: "${path} musia byť aspoň ${min} znaky",
  max: "${path} musia byť nanajvýš ${max} znaky",
  matches: "${path} sa musí zhodovať s nasledujúcimi: „${regex}“",
  email: "${path} musí byť platný e-mail",
  url: "${path} musí byť platná adresa URL",
  uuid: "${path} musí byť platný uuid",
  trim: "${path} musí byť orezaný reťazec",
  lowercase: "${path} musí byť malý reťazec",
  uppercase: "${path} Musí to byť strun s vyšším písmom"
};
var number$l = {
  min: "${path} musí byť väčší alebo rovný ${min}",
  max: "${path} musí byť menšie alebo rovné ${max}",
  lessThan: "${path} musí byť menej ako ${less}",
  moreThan: "${path} musí byť väčší ako ${more}",
  positive: "${path} musí byť kladné číslo",
  negative: "${path} musí byť záporné číslo",
  integer: "${path} musí byť celé číslo"
};
var date$l = {
  min: "${path} pole musí byť neskôr ako ${min}",
  max: "${path} Pole musí byť skôr ako ${max}"
};
var _boolean$l = {
  isValue: "${path} pole musí byť ${value}"
};
var object$l = {
  noUnknown: "${path} Pole nemôže mať kľúče zadané v tvare objektu"
};
var array$l = {
  min: "${path} pole musí mať aspoň ${min} položky",
  max: "${path} pole musí mať menej ako položky ${max}",
  length: "${path} musia mať položky ${length}"
};
var sk = {
  __proto__: null,
  mixed: mixed$l,
  string: string$l,
  number: number$l,
  date: date$l,
  boolean: _boolean$l,
  object: object$l,
  array: array$l
};
var mixed$m = {
  "default": "${path} ไม่ถูกต้อง",
  required: "${path} เป็นฟิลด์ที่จำเป็น",
  defined: "${path} ต้องกำหนด",
  notNull: "${path} ไม่สามารถเป็นโมฆะได้",
  oneOf: "${path} ต้องเป็นหนึ่งในค่าต่อไปนี้: ${values}",
  notOneOf: "${path} ต้องไม่เป็นหนึ่งในค่าต่อไปนี้: ${values}",
  notType: function notType23(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " ต้องเป็น `" + type + "` ประเภท, " + ("แต่ค่าสุดท้ายคือ: `" + printValue(value, true) + "`") + (isCast ? " (หล่อจากค่า `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n หาก "null" มีวัตถุประสงค์เพื่อเป็นค่าว่างให้แน่ใจว่าทำเครื่องหมายสคีมาเป็น `.nullable()`';
    }
    return msg;
  }
};
var string$m = {
  length: "${path} ต้องเป็นตัวละคร ${length}",
  min: "${path} อย่างน้อย ${min} ตัวละคร",
  max: "${path} ต้องเป็นตัวละครมากที่สุด ${max}",
  matches: '${path} ต้องตรงกับสิ่งต่อไปนี้: "${regex}"',
  email: "${path} ต้องเป็นอีเมลที่ถูกต้อง",
  url: "${path} ต้องเป็น URL ที่ถูกต้อง",
  uuid: "${path} ต้องเป็น UUID ที่ถูกต้อง",
  trim: "${path} ต้องเป็นสตริงที่ถูกตัดแต่ง",
  lowercase: "${path} ต้องเป็นสตริงตัวพิมพ์เล็ก",
  uppercase: "${path} ต้องเป็นสตริงตัวพิมพ์ใหญ่"
};
var number$m = {
  min: "${path} ต้องมากกว่าหรือเท่ากับ ${min}",
  max: "${path} ต้องน้อยกว่าหรือเท่ากับ ${max}",
  lessThan: "${path} ต้องน้อยกว่า ${less}",
  moreThan: "${path} ต้องมากกว่า ${more}",
  positive: "${path} ต้องเป็นจำนวนบวก",
  negative: "${path} ต้องเป็นจำนวนลบ",
  integer: "${path} ต้องเป็นจำนวนเต็ม"
};
var date$m = {
  min: "${path} ฟิลด์ต้องช้ากว่า ${min}",
  max: "${path} ฟิลด์ต้องอยู่ที่เร็วกว่า ${max}"
};
var _boolean$m = {
  isValue: "${path} ฟิลด์ต้องเป็น ${value}"
};
var object$m = {
  noUnknown: "${path} ฟิลด์ไม่สามารถระบุคีย์ได้ในรูปร่างของวัตถุ"
};
var array$m = {
  min: "${path} ฟิลด์ต้องมีอย่างน้อย ${min} รายการ",
  max: "${path} ฟิลด์ต้องมีน้อยกว่าหรือเท่ากับ ${max} รายการ",
  length: "${path} ต้องมี ${length} รายการ"
};
var th = {
  __proto__: null,
  mixed: mixed$m,
  string: string$m,
  number: number$m,
  date: date$m,
  boolean: _boolean$m,
  object: object$m,
  array: array$m
};
var mixed$n = {
  "default": "${path} geçersiz.",
  required: "${path} gerekli bir alandır",
  defined: "${path} tanımlanmalıdır",
  notNull: "${path} boş olamaz",
  oneOf: "${path} aşağıdaki değerlerden biri olmalıdır: ${values}",
  notOneOf: "${path} aşağıdaki değerlerden biri olmamalıdır: ${values}",
  notType: function notType24(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " `" + type + "` `Türü olmalıdır, " + ("Ancak son değer şuydu: `" + printValue(value, true) + "`") + (isCast ? " (`" + printValue(originalValue, true) + " 'değerinden döküm)." : ".");
    if (value === null) {
      msg += '\n "NULL" boş bir değer olarak tasarlanmışsa, şemayı şöyle işaretlediğinizden emin olun `.nullable()`';
    }
    return msg;
  }
};
var string$n = {
  length: "${path} tam olarak ${length} karakterler olmalı",
  min: "${path} en azından ${min} karakterler olmalı",
  max: "${path} en fazla ${max} karakterler olmalı",
  matches: '${path} aşağıdakilerle eşleşmelidir: "${regex}"',
  email: "${path} geçerli bir e -posta olmalı",
  url: "${path} geçerli bir URL olmalı",
  uuid: "${path} geçerli bir UUID olmalı",
  trim: "${path} Kesilmiş bir ip olmalı",
  lowercase: "${path} küçük harfli bir ip olmalı",
  uppercase: "${path} büyük harfli bir ip olmalı"
};
var number$n = {
  min: "${path} ${min} 'dan büyük veya eşit olmalıdır.",
  max: "${path} ${max} 'dan az veya eşit olmalıdır.",
  lessThan: "${path} ${less} 'dan daha az olmalıdır",
  moreThan: "${path} ${more} 'dan daha büyük olmalıdır",
  positive: "${path} pozitif bir sayı olmalı",
  negative: "${path} negatif bir sayı olmalı",
  integer: "${path} bir tamsayı olmalı"
};
var date$n = {
  min: "${path} Alan ${min} 'dan daha geç olmalıdır",
  max: "${path} Alan ${max} 'dan daha erken olmalıdır."
};
var _boolean$n = {
  isValue: "${path} Alan ${value} olmalıdır"
};
var object$n = {
  noUnknown: "${path} Alan, nesne şeklinde belirtilmeyen anahtarlara sahip olamaz"
};
var array$n = {
  min: "${path} Alanın en az ${min} öğeleri olmalı",
  max: "${path} Alanın ${max} öğelere eşit veya daha az olması gerekir",
  length: "${path} ${length} öğeleri olmalı"
};
var tr = {
  __proto__: null,
  mixed: mixed$n,
  string: string$n,
  number: number$n,
  date: date$n,
  boolean: _boolean$n,
  object: object$n,
  array: array$n
};
var mixed$o = {
  "default": "${path} yaroqsiz.",
  required: "${path} - bu majburiy maydon",
  defined: "${path} aniqlanishi kerak",
  notNull: "${path} null bo'lolmaydi",
  oneOf: "${path} quyidagi qiymatlardan biri bo'lishi kerak: ${values}",
  notOneOf: "${path} quyidagi qiymatlardan biri bo'lmasligi kerak: ${values}",
  notType: function notType25(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + ' a "' + type + "` to, " + ("Ammo yakuniy qiymat: '" + printValue(value, true) + " `") + (isCast ? " (`" + printValue(originalValue, true) + " qiymatidan)." : ".");
    if (value === null) {
      msg += "\n Agar \"null\" bo'sh qiymat sifatida mo'ljallangan bo'lsa, buxorni belgilang `.nullable()`";
    }
    return msg;
  }
};
var string$o = {
  length: "${path} aniq ${length} belgilar bo'lishi kerak",
  min: "${path} hech bo'lmaganda ${min} belgilar bo'lishi kerak",
  max: "${path} ko'pchilik ${max} belgilar bo'lishi kerak",
  matches: '${path} quyidagilarga mos kelishi kerak: "${regex}"',
  email: "${path} to'g'ri elektron pochta bo'lishi kerak",
  url: "${path} yaroqli url bo'lishi kerak",
  uuid: "${path} haqiqiy uuid bo'lishi kerak",
  trim: "${path} qirqilgan satr bo'lishi kerak",
  lowercase: "${path} kichik harfli satr bo'lishi kerak",
  uppercase: "${path} katta satr bo'lishi kerak"
};
var number$o = {
  min: "${path} ${min} dan katta yoki teng bo'lishi kerak]",
  max: "${path} dan kam yoki unga teng bo'lishi kerak ${max}",
  lessThan: "${path} dan kamroq bo'lishi kerak ${less}",
  moreThan: "${path} dan katta bo'lishi kerak ${more}",
  positive: "${path} ijobiy raqam bo'lishi kerak",
  negative: "${path} Salbiy raqam bo'lishi kerak",
  integer: "${path} butun son bo'lishi kerak"
};
var date$o = {
  min: "${path} dalasi ${min} dan keyinroq bo'lishi kerak",
  max: "${path} Maydon ${max} dan avvalroq bo'lishi kerak]"
};
var _boolean$o = {
  isValue: "${path} Maydon ${value}"
};
var object$o = {
  noUnknown: "${path} maydon ob'ekt shaklida ko'rsatilmagan kalitlarga ega bo'lolmaydi"
};
var array$o = {
  min: "${path} Maydon kamida ${min} elementlari bo'lishi kerak",
  max: "${path} Maydon ${max} elementlarga qaraganda kam yoki teng bo'lishi kerak",
  length: "${path} ${length}"
};
var uz = {
  __proto__: null,
  mixed: mixed$o,
  string: string$o,
  number: number$o,
  date: date$o,
  boolean: _boolean$o,
  object: object$o,
  array: array$o
};
var mixed$p = {
  "default": "${path} không hợp lệ.",
  required: "${path} là một trường bắt buộc",
  defined: "${path} phải được xác định",
  notNull: "${path} không thể là NULL",
  oneOf: "${path} phải là một trong các giá trị sau: ${values}",
  notOneOf: "${path} Không được là một trong các giá trị sau: ${values}",
  notType: function notType26(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " phải là một `" + type + "`, " + ("Nhưng giá trị cuối cùng là: `" + printValue(value, true) + "`") + (isCast ? " (đúc từ giá trị `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Nếu "null" được dự định là một giá trị trống, hãy chắc chắn đánh dấu lược đồ là `.nullable()`';
    }
    return msg;
  }
};
var string$p = {
  length: "${path} phải chính xác là ${length} ký tự",
  min: "${path} phải ít nhất ${min} ký tự",
  max: "${path} nhất phải là các ký tự ${max}",
  matches: '${path} phải phù hợp như sau: "${regex}"',
  email: "${path} phải là một email hợp lệ",
  url: "${path} phải là một URL hợp lệ",
  uuid: "${path} phải là UUID hợp lệ",
  trim: "${path} phải là một chuỗi được cắt",
  lowercase: "${path} phải là chuỗi chữ thường",
  uppercase: "${path} phải là chuỗi trường hợp trên"
};
var number$p = {
  min: "${path} phải lớn hơn hoặc bằng ${min}",
  max: "${path} phải nhỏ hơn hoặc bằng ${max}",
  lessThan: "${path} phải nhỏ hơn ${less}",
  moreThan: "${path} phải lớn hơn ${more}",
  positive: "${path} phải là một số dương",
  negative: "${path} phải là số âm",
  integer: "${path} phải là một số nguyên"
};
var date$p = {
  min: "${path} Trường phải muộn hơn ${min}",
  max: "${path} Trường phải sớm hơn ${max}"
};
var _boolean$p = {
  isValue: "${path} Trường phải là ${value}"
};
var object$p = {
  noUnknown: "${path} Trường không thể có các khóa không được chỉ định trong hình dạng đối tượng"
};
var array$p = {
  min: "${path} Trường phải có ít nhất ${min} các mục",
  max: "${path} Trường phải có ít hơn hoặc bằng các mục ${max}",
  length: "${path} Phải có ${length} các mục"
};
var vi = {
  __proto__: null,
  mixed: mixed$p,
  string: string$p,
  number: number$p,
  date: date$p,
  boolean: _boolean$p,
  object: object$p,
  array: array$p
};
var mixed$q = {
  "default": "${path}无效。",
  required: "${path}是必需的字段",
  defined: "${path}必须定义",
  notNull: "${path}不能无效",
  oneOf: "${path}必须是以下值之一：${values}",
  notOneOf: "${path}不能是以下值之一：${values}",
  notType: function notType27(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + "必须是`" + type + ", " + ("但最终值是：`" + printValue(value, true) + "``") + (isCast ? " (从值`" + printValue(originalValue, true) + "```'')." : ".");
    if (value === null) {
      msg += "\n 如果“null”故意为空值, 请务必将架构标记为 `.nullable()`";
    }
    return msg;
  }
};
var string$q = {
  length: "${path}必须完全是${length}字符",
  min: "${path}至少必须是${min}字符",
  max: "${path}最多必须是${max}字符",
  matches: "${path}必须匹配以下：“ ${regex}”",
  email: "${path}必须是一封有效的电子邮件",
  url: "${path}必须是有效的URL",
  uuid: "${path}必须是有效的UUID",
  trim: "${path}必须是修剪的字符串",
  lowercase: "${path}必须是小写字符串",
  uppercase: "${path}必须是大写字符串"
};
var number$q = {
  min: "${path}必须大于或等于${min}",
  max: "${path}必须小于或等于${max}",
  lessThan: "${path}必须小于${less}",
  moreThan: "${path}必须大于${more}",
  positive: "${path}必须是一个正数",
  negative: "${path}必须是负数",
  integer: "${path}必须是一个整数"
};
var date$q = {
  min: "${path}字段必须比${min}晚。",
  max: "${path}字段必须早于${max}"
};
var _boolean$q = {
  isValue: "${path}字段必须为${value}"
};
var object$q = {
  noUnknown: "${path}字段不能具有对象形状中未指定的键"
};
var array$q = {
  min: "${path}字段至少必须具有${min}项目",
  max: "${path}字段必须小于或等于${max}项目",
  length: "${path}必须有${length}项目"
};
var zh = {
  __proto__: null,
  mixed: mixed$q,
  string: string$q,
  number: number$q,
  date: date$q,
  boolean: _boolean$q,
  object: object$q,
  array: array$q
};
var mixed$r = {
  "default": "${path} 無效。",
  required: "${path} 是必需的字段",
  oneOf: "${path} 必須是以下值之一： ${values}",
  notOneOf: "${path} 不能是以下值之一：${values}",
  notType: function notType28(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " 必須是`" + type + ", " + ("但最終值是：`" + printValue(value, true) + "``") + (isCast ? " (從值`" + printValue(originalValue, true) + "```'')." : ".");
    if (value === null) {
      msg += "\n 如果“ null”是為空值，請確保將架構標記為 `.nullable()`";
    }
    return msg;
  }
};
var string$r = {
  length: "${path} 必須完全是 ${length} 字符",
  min: "${path} 至少必須是 ${min} 字符",
  max: "${path} 最多必須是 ${max} 字符",
  matches: '${path} 必須匹配以下： "${regex}"',
  email: "${path} 必須是一封有效的電子郵件",
  url: "${path} 必須是有效的URL",
  trim: "${path} 必須是修剪的字符串",
  lowercase: "${path} 必須是小寫字符串",
  uppercase: "${path} 必須是大寫字符串"
};
var number$r = {
  min: "${path} 必須大於或等於 ${min}",
  max: "${path} 必須小於或等於 ${max}",
  lessThan: "${path} 必須小於 ${less}",
  moreThan: "${path} 必須大於 ${more}",
  positive: "${path} 必須是一個正數",
  negative: "${path} 必須是負數",
  integer: "${path} 必須是一個整數"
};
var date$r = {
  min: "${path} 字段必須比${min}晚。",
  max: "${path} 字段必須早於${max}"
};
var _boolean$r = {};
var object$r = {
  noUnknown: "${path} 字段不能具有對象形狀中未指定的鍵"
};
var array$r = {
  min: "${path} 字段至少必須具有 ${min} 項目",
  max: "${path} 字段必須小於或等於 ${max} 項目"
};
var zhtw = {
  __proto__: null,
  mixed: mixed$r,
  string: string$r,
  number: number$r,
  date: date$r,
  boolean: _boolean$r,
  object: object$r,
  array: array$r
};
var mixed$s = {
  "default": "${path} este invalid.",
  required: "${path} este un câmp obligatoriu",
  defined: "${path} trebuie să fie definit",
  notNull: "${path} nu poate fi nul",
  oneOf: "${path} trebuie să fie una dintre următoarele valori: ${values}",
  notOneOf: "${path} nu trebuie să fie una dintre următoarele valori: ${values}",
  notType: function notType29(_ref) {
    var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " trebuie să fie de tipul `" + type + "`, " + ("dar valoarea finală a fost: `" + printValue(value, true) + "`") + (isCast ? " (de la valoarea `" + printValue(originalValue, true) + "`)." : ".");
    if (value === null) {
      msg += '\n Dacă "NULL" a fost destinat ca o valoare goală, asigurați-vă că schema dvs. o marchează `.nullable()`';
    }
    return msg;
  }
};
var string$s = {
  length: "${path} trebuie să aibă exact ${length} caractere",
  min: "${path} trebuie să aibă cel puțin ${min} caractere",
  max: "${path} trebuie să aibă cel mult ${max} caractere",
  matches: '${path} trebuie să se potrivească cu: "${regex}"',
  email: "${path} trebuie să fie un e-mail valid",
  url: "${path} trebuie să fie un URL valid",
  uuid: "${path} trebuie să fie un UUID valid",
  trim: "${path} trebuie să fie un șir tăiat",
  lowercase: "${path} trebuie să fie un șir cu litere mici",
  uppercase: "${path} trebuie să fie un șir cu litere mari"
};
var number$s = {
  min: "${path} trebuie să fie mai mare sau egal cu ${min}.",
  max: "${path} trebuie să fie mai mic sau egal cu ${max}.",
  lessThan: "${path} trebuie să fie mai mic decât ${less}",
  moreThan: "${path} trebuie să fie mai mare decât ${more}",
  positive: "${path} trebuie să fie un număr pozitiv",
  negative: "${path} trebuie să fie un număr negativ",
  integer: "${path} trebuie să fie un întreg"
};
var date$s = {
  min: "${path} câmpul trebuie să fie după ${min}",
  max: "${path} câmpul trebuie să fie înainte de ${max}."
};
var _boolean$s = {
  isValue: "${path} câmpul trebuie să fie ${value}"
};
var object$s = {
  noUnknown: "${path} câmpul nu poate avea chei care nu sunt specificate în forma obiectului"
};
var array$s = {
  min: "${path} câmpul trebuie să aibă cel puțin ${min} elemente",
  max: "${path} câmpul trebuie să aibă cel mult ${max} elemente",
  length: "${path} trebuie să aibă ${length} elemente"
};
var ro = {
  __proto__: null,
  mixed: mixed$s,
  string: string$s,
  number: number$s,
  date: date$s,
  boolean: _boolean$s,
  object: object$s,
  array: array$s
};
export {
  ar,
  bg,
  bs,
  cs,
  da,
  de,
  en,
  es,
  fr,
  he,
  hu,
  id,
  it,
  ja,
  ko,
  lt,
  nb,
  nl,
  pl,
  pt,
  ro,
  ru,
  sk,
  th,
  tr,
  uz,
  vi,
  zh,
  zhtw
};
//# sourceMappingURL=yup-locales.js.map
